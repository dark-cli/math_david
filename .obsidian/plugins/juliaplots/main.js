/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => JuliaPlots
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");
var import_child_process = require("child_process");
var path = __toESM(require("path"));
var import_obsidian4 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  xmin: -10,
  xmax: 10,
  num_points: 100,
  x_label: "x",
  y_label: "y",
  ymin: -10,
  ymax: 10,
  z_label: "z",
  dark_mode: false,
  color: "#1E90FF",
  line_width: 2,
  scatter_color: "#1E90FF"
};
var JuliaPlotsSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("\u{1F4D0} Default parameters").setHeading();
    new import_obsidian.Setting(containerEl).setName("Default xmin").setDesc("Default minimum x value for the plot").addText((text) => text.setPlaceholder("Example: -10").setValue(this.plugin.settings.xmin.toString()).onChange(async (value) => {
      this.plugin.settings.xmin = parseFloat(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default xmax").setDesc("Default maximum x value for the plot").addText((text) => text.setPlaceholder("Example: 10").setValue(this.plugin.settings.xmax.toString()).onChange(async (value) => {
      this.plugin.settings.xmax = parseFloat(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default number of points").setDesc("Default number of points to plot on the graph (\u26A0\uFE0F Notice that a higher number of points will result in a smoother graph, but maybe will take longer to generate)").addText((text) => text.setPlaceholder("Example: 100").setValue(this.plugin.settings.num_points.toString()).onChange(async (value) => {
      this.plugin.settings.num_points = parseFloat(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default x label").setDesc("Default label for the x-axis of the graph").addText((text) => text.setPlaceholder("Example: Time (s)").setValue(this.plugin.settings.x_label.toString()).onChange(async (value) => {
      this.plugin.settings.x_label = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default y label").setDesc("Default label for the y-axis of the graph").addText((text) => text.setPlaceholder("Example:  Velocity (m/s)").setValue(this.plugin.settings.y_label.toString()).onChange(async (value) => {
      this.plugin.settings.y_label = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("\u{1F3C8} 3D functions").setHeading();
    new import_obsidian.Setting(containerEl).setName("Default ymin").setDesc("Default minimum y value for the 3D plot").addText((text) => text.setPlaceholder("Example:  -10").setValue(this.plugin.settings.ymin.toString()).onChange(async (value) => {
      this.plugin.settings.ymin = parseFloat(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default ymax").setDesc("Default maximum y value for the 3D plot").addText((text) => text.setPlaceholder("Example:  10").setValue(this.plugin.settings.ymax.toString()).onChange(async (value) => {
      this.plugin.settings.ymax = parseFloat(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default z label").setDesc("Default label for the z-axis of the 3D graph").addText((text) => text.setPlaceholder("Example:  Height (m)").setValue(this.plugin.settings.z_label.toString()).onChange(async (value) => {
      this.plugin.settings.z_label = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("\u{1F3A8} Graph appearance").setHeading();
    new import_obsidian.Setting(containerEl).setName("Dark mode").setDesc("If enabled, the graph will generate with a transparent background and white text and lines").addToggle((toggle) => toggle.setValue(this.plugin.settings.dark_mode).onChange(async (value) => {
      this.plugin.settings.dark_mode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Graph color").setDesc("Default color for the graph line").addColorPicker((color) => color.setValue(this.plugin.settings.color).onChange(async (value) => {
      this.plugin.settings.color = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Line width").setDesc("Default width of the graph line").addText((text) => text.setPlaceholder("Example: 2").setValue(this.plugin.settings.line_width.toString()).onChange(async (value) => {
      this.plugin.settings.line_width = parseFloat(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Scatter color").setDesc("Default color for the scatter points").addColorPicker((color) => color.setValue(this.plugin.settings.scatter_color).onChange(async (value) => {
      this.plugin.settings.scatter_color = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("\u{1F497} Thanks for using my plugin! Any suggestion, contribution, or bug report will be very appreciated!").setHeading();
  }
};

// src/command.ts
var import_obsidian2 = require("obsidian");
var JuliaPlotsModal = class extends import_obsidian2.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u{1F4C8} Insert JuliaPlots quick graph" });
    const fields = {};
    const params = [
      { key: "function", label: "Functions", placeholder: "e.g. f(x)=x^2" },
      { key: "scatter", label: "Scatter Points", placeholder: "e.g. 1,2 ; 3,4,red,I'm a point!" },
      { key: "title", label: "Title", placeholder: "My Graph" }
    ];
    for (const param of params) {
      if (param.key === "function" || param.key === "scatter") {
        new import_obsidian2.Setting(contentEl).setName(param.label).addTextArea((text) => {
          text.setPlaceholder(param.placeholder).setValue("").onChange((value) => {
            fields[param.key].value = value;
          });
          fields[param.key] = text.inputEl;
        });
      } else {
        new import_obsidian2.Setting(contentEl).setName(param.label).addText((text) => {
          text.setPlaceholder(param.placeholder).setValue("").onChange((value) => {
            fields[param.key].value = value;
          });
          fields[param.key] = text.inputEl;
        });
      }
    }
    const submitButton = contentEl.createEl("button", { text: "Insert graph" });
    submitButton.onclick = () => {
      const values = {};
      for (const key in fields) {
        values[key] = fields[key].value;
      }
      this.onSubmit(values);
      this.close();
    };
  }
};

// src/main.ts
var JuliaPlots = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerMarkdownCodeBlockProcessor("juliaplots", async (source, el, ctx) => {
      const params = parseParams(source);
      const outputPath = await getPath(source, params, this.settings);
      const outputPathAbs = path.join(this.app.vault.adapter.basePath, outputPath);
      const loadingMsg = el.createEl("span", { text: "\u23F3 Generating Julia Plot..." });
      try {
        await generateJuliaPlot(params, outputPathAbs, this.settings);
        loadingMsg.remove();
        insertGraph(el, outputPathAbs);
      } catch (error) {
        el.createEl("pre", { text: `Error generating plot: ${error}` });
      }
    });
    this.addCommand({
      id: "insert-graph",
      name: "Insert a quick JuliaPlots graph",
      editorCallback: (editor, view) => {
        new JuliaPlotsModal(this.app, async (params) => {
          const lines = ["```juliaplots"];
          if (params.function)
            lines.push(`${params.function}`);
          if (params.scatter)
            lines.push(`scatter=${params.scatter}`);
          if (params.title)
            lines.push(`title=${params.title}`);
          lines.push("```");
          editor.replaceSelection(lines.join("\n"));
        }).open();
      }
    });
    this.addSettingTab(new JuliaPlotsSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
function parseParams(source) {
  const lines = source.split("\n");
  const result = {};
  for (const line of lines) {
    const [key, value] = line.split("=");
    if (key && value) {
      result[key.trim()] = value.trim();
    }
  }
  return result;
}
async function getPath(source, params, settings) {
  const dir = "juliaplots";
  if (!await this.app.vault.adapter.exists(dir)) {
    await this.app.vault.createFolder(dir);
  }
  const functionParams = Object.entries(params).filter(([key, value]) => key.trim().endsWith("(x)") || key.trim().endsWith("(x,y)")).map(([key, val]) => `${key.trim()}=${val.trim()}`);
  const hashInput = functionParams.join("|");
  const crypto = require("crypto");
  const hash = crypto.createHash("sha256").update(hashInput).digest("hex").slice(0, 10);
  return `${dir}/plot-${hash}.png`;
}
async function generateJuliaPlot(params, outputPath, settings) {
  const juliaScriptPath = path.join(this.app.vault.adapter.getBasePath(), this.app.vault.configDir, "plugins", "juliaplots", "juliaplots.jl");
  const allParams = {
    ...settings,
    ...params,
    output_path: outputPath
  };
  const args = [juliaScriptPath];
  for (const [key, value] of Object.entries(allParams)) {
    args.push(`${key}=${value}`);
  }
  return new Promise((resolve, reject) => {
    const julia = (0, import_child_process.spawn)("julia", args);
    let stderr = "";
    let stdout = "";
    julia.stdout.on("data", (data) => {
      stdout += data.toString();
    });
    julia.stderr.on("data", (data) => {
      stderr += data.toString();
    });
    julia.on("error", (err) => {
      if (err) {
        reject(`Julia could not be initialized. Please make sure that Julia is installed on your system and that it is included on your PATH: ${err.message}`);
      }
    });
    julia.on("close", (code) => {
      if (code === 0) {
        resolve();
      } else {
        const msg = [stdout.trim(), stderr.trim()].filter(Boolean).join("\n") || `Julia process exited with code ${code}`;
        reject(msg);
      }
    });
  });
}
function insertGraph(el, graphPath) {
  const vaultBase = this.app.vault.adapter.getBasePath();
  const relativePath = path.relative(vaultBase, graphPath).replace(/\\/g, "/");
  const file = this.app.vault.getAbstractFileByPath(relativePath);
  const container = el.createDiv({ cls: "juliaplots-graph-container" });
  let img = document.createElement("img");
  img.alt = "Julia Plot";
  if (file instanceof import_obsidian4.TFile) {
    img.src = this.app.vault.getResourcePath(file);
  } else {
    img.src = relativePath;
  }
  container.appendChild(img);
}


/* nosourcemap */